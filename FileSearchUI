import os
import re
import tkinter as tk
from tkinter import filedialog, ttk
from pathlib import Path
import webbrowser
import random


class FileSearchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("File Search and Sort")
        self.root.geometry("1200x800")

        self.folder_path = tk.StringVar(value="D:/ABogue/Books/")
        self.search_patterns = tk.StringVar(value="pytorch, python")
        self.extensions = tk.StringVar(value="")  # Blank means search all
        self.sort_by = tk.StringVar(value="published, publisher, modified")
        self.publisher_filters = tk.StringVar()
        self.limit = tk.IntVar(value=10)

        self.all_results = []  # Store all search results
        self.create_widgets()

    def create_widgets(self):
        frame = ttk.Frame(self.root)
        frame.pack(pady=10, padx=10, fill=tk.X)

        ttk.Button(frame, text="Select Folder", command=self.select_folder).grid(row=0, column=0, sticky=tk.W, padx=5)
        ttk.Label(frame, textvariable=self.folder_path, foreground="green").grid(row=0, column=1, sticky=tk.W, padx=5)

        self.add_input(frame, "Search Patterns (Supports Korean):", self.search_patterns, 1)
        self.add_input(frame, "File Extensions (Leave blank for all):", self.extensions, 2)
        self.add_input(frame, "Sort By:", self.sort_by, 3)
        self.add_input(frame, "Publisher Filters:", self.publisher_filters, 4)

        ttk.Label(frame, text="Limit:").grid(row=5, column=0, sticky=tk.W, padx=5)
        ttk.Entry(frame, textvariable=self.limit, width=10).grid(row=5, column=1, sticky=tk.W, padx=5)

        ttk.Button(frame, text="Search Files", command=self.search_files).grid(row=6, column=0, columnspan=2, pady=10)

        # Filter input field
        ttk.Label(self.root, text="Filter Results:").pack(pady=5)
        self.filter_var = tk.StringVar()
        self.filter_entry = ttk.Entry(self.root, textvariable=self.filter_var, width=50)
        self.filter_entry.pack()
        self.filter_entry.bind("<KeyRelease>", self.filter_results)  # Event binding

        # Results Textbox with Highlighting
        self.results_frame = ttk.Frame(self.root, padding=10)
        self.results_frame.pack(fill=tk.BOTH, expand=True)
        self.results_text = tk.Text(self.results_frame, wrap=tk.WORD, height=15, font=("Arial", 11))
        self.results_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.results_text.bind("<Double-Button-1>", self.open_file)

    def add_input(self, frame, label, var, row):
        ttk.Label(frame, text=label).grid(row=row, column=0, sticky=tk.W, padx=5)
        ttk.Entry(frame, textvariable=var, width=50).grid(row=row, column=1, sticky=tk.W, padx=5)

    def select_folder(self):
        folder = filedialog.askdirectory()
        if folder:
            self.folder_path.set(folder)

    def search_files(self):
        folder = Path(self.folder_path.get())
        if not folder.exists():
            return

        include_patterns, exclude_patterns = self.get_patterns(self.search_patterns.get())

        # Process file extensions (if blank, include all)
        ext_input = self.extensions.get().strip().lower()
        extensions = [ext.strip() for ext in ext_input.split(",") if ext] if ext_input else None  # None means all files

        sort_by = [s.strip().lower() for s in self.sort_by.get().split(",")]
        include_publishers, exclude_publishers = self.get_patterns(self.publisher_filters.get())

        files = []
        for file in folder.glob("**/*"):  # Search in all subdirectories
            if not file.is_file():
                continue

            filename = file.name.lower()
            file_ext = file.suffix[1:].lower()  # Get the file extension (without the dot)

            # If extensions are specified, only include matching ones
            if extensions and file_ext not in extensions:
                continue

            # Use case-insensitive Unicode matching (supports Korean)
            if include_patterns and not any(re.search(re.escape(p), filename, re.IGNORECASE) for p in include_patterns):
                continue
            if any(re.search(re.escape(p), filename, re.IGNORECASE) for p in exclude_patterns):
                continue

            publisher = self.extract_publisher(filename)
            if include_publishers and publisher not in include_publishers:
                continue
            if publisher in exclude_publishers:
                continue

            files.append((file, self.extract_year(filename), publisher, file.stat().st_mtime))

        files.sort(key=lambda x: self.get_sort_key(x, sort_by), reverse=True)

        # Store all results before filtering
        self.all_results = files[:self.limit.get()]
        self.display_results(self.all_results, include_patterns)

    def get_patterns(self, pattern_str):
        patterns = [p.strip() for p in pattern_str.split(",") if p.strip()]
        return ([p for p in patterns if not p.startswith("-")],
                [p[1:] for p in patterns if p.startswith("-")])

    def extract_year(self, filename):
        match = re.search(r'\b(19\d{2}|20\d{2})\b', filename)
        return int(match.group()) if match else 0

    def extract_publisher(self, filename):
        match = re.match(r'([^\-]+)-', filename)
        return match.group(1).strip().lower() if match else "unknown"

    def get_sort_key(self, file_data, sort_by):
        file, year, publisher, modified = file_data
        key = []
        for criteria in sort_by:
            if criteria == "published":
                key.append(year)
            elif criteria == "publisher":
                key.append(publisher)
            elif criteria == "modified":
                key.append(modified)
        return tuple(key)

    def display_results(self, files, highlight_patterns):
        """ Displays the results and highlights search patterns. """
        self.results_text.delete("1.0", tk.END)

        colors = self.generate_bright_colors(len(highlight_patterns))
        color_map = dict(zip(highlight_patterns, colors))

        for file, year, publisher, _ in files:
            file_text = f"{file.name}\n"
            self.results_text.insert(tk.END, file_text)

            # Apply highlighting for each search pattern
            for pattern, color in color_map.items():
                self.highlight_pattern(file_text, pattern, color)

    def highlight_pattern(self, text, pattern, color):
        """ Highlights a search pattern in the results text box. """
        start_index = "1.0"
        while True:
            start_index = self.results_text.search(pattern, start_index, stopindex=tk.END, nocase=True)
            if not start_index:
                break
            end_index = f"{start_index}+{len(pattern)}c"
            self.results_text.tag_add(pattern, start_index, end_index)
            self.results_text.tag_config(pattern, foreground=color, font=("Arial", 11, "bold"))
            start_index = end_index

    def generate_bright_colors(self, num_colors):
        """ Generates a list of bright colors for highlighting. """
        return [f"#{random.randint(180, 255):02X}{random.randint(100, 200):02X}{random.randint(50, 150):02X}" for _ in range(num_colors)]

    def filter_results(self, event):
        """ Dynamically filters the displayed results based on user input. """
        query = self.filter_var.get().lower()
        filtered_files = [f for f in self.all_results if query in f[0].name.lower()]
        self.display_results(filtered_files, self.search_patterns.get().split(","))

    def open_file(self, event):
        selected = self.results_text.get(tk.SEL_FIRST, tk.SEL_LAST).strip()
        if selected:
            file_path = Path(self.folder_path.get()) / selected
            if file_path.exists():
                webbrowser.open(file_path.as_uri())


if __name__ == "__main__":
    root = tk.Tk()
    app = FileSearchApp(root)
    root.mainloop()
